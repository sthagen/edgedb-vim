import pathlib
import textwrap

import meta


FILE_PREFIX = '''\
" AUTOGENERATED WITH `make regen-grammar`
'''
NOT_PATH = r'\(\.\|\.<\|\.>\)\@<!'
NOT_FQPATH = r'\(::\|\.\|\.<\|\.>\)\@<!'
# some unreserved keywords have special handling because they clash
# with builtins
EXCEPTION_KW = {'named', 'text'}


def join(it, sep=R'\|'):
    return sep.join(it)


def main():
    base_path = pathlib.Path(__file__).resolve().parent.parent
    EdgeQL = meta.EdgeQL

    dunder_builtins = [kw for kw in EdgeQL.reserved_keywords
                       if kw[:2] == '__']
    fn_builtins = sorted(EdgeQL.fn_builtins)
    constraint_builtins = sorted(set(EdgeQL.constraint_builtins) - {'constraint'})
    type_builtins = sorted(set(EdgeQL.type_builtins) | {'anytype'})

    unreserved_keywords = sorted(
      set(EdgeQL.unreserved_keywords)
      # special keywords that have other meaning
      - set(dunder_builtins)
      - set(type_builtins)
      - set(constraint_builtins)
      - EXCEPTION_KW
    )
    reserved_keywords = sorted(
      set(EdgeQL.reserved_keywords)
      # special keywords that have other meaning
      - set(dunder_builtins)
      - set(type_builtins)
    )

    stdmodules = EdgeQL.module_builtins
    # Operators need to be sorted from longest to shortest to match
    # correctly. Lexicographical sort is added on top of that for
    # stability, but is not itself important.
    operators = sorted(EdgeQL.operators,
                       key=lambda x: (len(x), x), reverse=True)
    # the operator ^ needs to be escaped
    operators = [f'\\{op}' if op == '^' else op for op in operators]

    # navigation punctuation needs to be processed similar to operators
    navigation = sorted(EdgeQL.navigation,
                        key=lambda x: (len(x), x), reverse=True)
    # the dot needs to be escaped
    navigation = [f'\\{nav}' if nav[0] == '.' else nav for nav in navigation
                  # exclude '.' and '@' for the moment
                  if nav not in {'.', '@'}]

    with open(base_path / 'syntax' / 'edgeql.vim', 'wt') as f:
        f.write(textwrap.dedent(Rf'''
        {FILE_PREFIX}

        if exists('b:current_syntax')
          finish
        endif

        syntax sync fromstart

        syntax match edgeqlComment /\m\#.*/
        syntax match edgeqlOp "\m{join(operators)}"
        syntax match edgeqlLinkprop /\m@\w\+/
        syntax match edgeqlNav "\m{join(navigation)}"

        syntax match edgeqlVar /\$\w\+/

        syntax match edgeqlDunders /\m\c\<\({join(dunder_builtins)}\)\>/
        syntax match edgeqlKeywords /\m\c\<{NOT_FQPATH}\(\(named \+only\)\|\(as \+text\)\|{join(reserved_keywords + unreserved_keywords)}\)\>/
        syntax match edgeqlModules /\m\c\<{NOT_FQPATH}\({join(stdmodules)}\)\>/
        syntax match edgeqlTypes /\m\c\<{NOT_PATH}\({join(type_builtins)}\)\>/
        syntax match edgeqlFnBuiltins /\m\c\<{NOT_PATH}\({join(fn_builtins)}\)\>/
        syntax match edgeqlConstraints /\m\c\<{NOT_PATH}\({join(constraint_builtins)}\)\>/
        syntax match edgeqlFloat /\m\w\@<!\(\(\(\d\+\(\.\d\+\)\?[eE]\([-+]\)\?\d\+\)\|\d\+\.\d\+\)n\?\)/
        syntax match edgeqlInt /\m\w\@<!\d\+\(\.\)\@!n\?/
        syntax match edgeqlBool /\m\ctrue\|false/

        syntax match edgeqlStr /\mr\?\(['"]\)\_.\{{-}}\1/
        syntax match edgeqlDollarStr /\mr\?\(\$\([A-Za-z\200-\377_][0-9]\*\)\*\$\)\_.\{{-}}\1/

        hi def link edgeqlComment Comment
        hi def link edgeqlOp Operator
        hi def link edgeqlNav Operator

        hi def link edgeqlLinkprop Label
        hi def link edgeqlVar Include

        hi def link edgeqlDunders Macro
        hi def link edgeqlKeywords Keyword
        hi def link edgeqlModules Include
        hi def link edgeqlTypes Type
        hi def link edgeqlFnBuiltins Function
        hi def link edgeqlConstraints Identifier

        hi def link edgeqlBool Boolean
        hi def link edgeqlInt Number
        hi def link edgeqlFloat Number
        hi def link edgeqlStr String
        hi def link edgeqlDollarStr String
        let b:current_syntax = 'edgeql'
        ''').strip())


if __name__ == '__main__':
    main()
